Author: Joan Bruguera <joanbrugueram@gmail.com>
Editor: Mingi Sung <FiestaLake@protonmail.com>
Subject: [PATCH] Fix for Linux 6.0 for NVIDIA 390.154 driver
---

Originally for nvidia-340xx.

---

--- a/nvidia/nv-acpi.c	2022-06-22 13:58:04.000000000 +0900
+++ b/nvidia/nv-acpi.c	2022-11-06 17:31:46.693815822 +0900
@@ -215,6 +215,53 @@
     return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+static struct nv_acpi_add_enumerated_data {
+	nv_acpi_t *object;
+	int *counter;
+};
+static int nv_acpi_add_enumerated(struct acpi_device *dev, void *data)
+{
+    struct nv_acpi_add_enumerated_data *rcvd_data = data;
+    nv_acpi_t *pNvAcpiObject = rcvd_data->object;
+    int *device_counter = rcvd_data->counter;
+    acpi_status status = -1;
+    nv_acpi_integer_t device_id = 0;
+    if (!dev)
+        return 0;
+    if (*device_counter == NV_MAXNUM_DISPLAY_DEVICES) {
+        nv_printf(NV_DBG_ERRORS, 
+            "NVRM: nv_acpi_add: Total number of devices cannot exceed %d\n", 
+            NV_MAXNUM_DISPLAY_DEVICES);
+        return 1;
+    }
+    status =
+        acpi_evaluate_integer(dev->handle, "_ADR", NULL, &device_id);
+    if (ACPI_FAILURE(status))
+        /* Couldnt query device_id for this device */
+        return 0;
+
+    device_id = (device_id & 0xffff);
+
+    if ((device_id != 0x100) && /* Not a known CRT device-id */ 
+        (device_id != 0x200) && /* Not a known TV device-id */ 
+        (device_id != 0x0110) && (device_id != 0x0118) && (device_id != 0x0400) && /* Not an LCD*/
+        (device_id != 0x0111) && (device_id != 0x0120) && (device_id != 0x0300)) /* Not a known DVI device-id */ 
+    {
+        /* This isnt a known device Id. 
+           Do default switching on this system. */
+        pNvAcpiObject->default_display_mask = 1;
+        return 1;
+    }
+
+    pNvAcpiObject->pNvVideo[*device_counter].dev_id = device_id;
+    pNvAcpiObject->pNvVideo[*device_counter].dev_handle = dev->handle;
+
+    (*device_counter)++;
+    return 0;
+}
+#endif
+
 static int nv_acpi_add(struct acpi_device *device)
 {
     /*
@@ -227,8 +274,10 @@
     union acpi_object control_argument_0 = { ACPI_TYPE_INTEGER };
     struct acpi_object_list control_argument_list = { 0, NULL };
     nvidia_stack_t *sp = NULL;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
     struct list_head *node, *next;
     nv_acpi_integer_t device_id = 0;
+#endif
     int device_counter = 0;
 
     status = nv_kmem_cache_alloc_stack(&sp);
@@ -256,6 +305,7 @@
 
     // grab handles to all the important nodes representing devices
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
     list_for_each_safe(node, next, &device->children) 
     {
         struct acpi_device *dev =
@@ -297,6 +347,13 @@
         device_counter++;
 
     }
+#else
+    struct nv_acpi_add_enumerated_data data = {
+        .object = pNvAcpiObject,
+        .counter = &device_counter,
+    };
+    acpi_dev_for_each_child(device, nv_acpi_add_enumerated, &data);
+#endif
 
     // arg 0, bits 1:0, 0 = enable events
     control_argument_0.integer.type = ACPI_TYPE_INTEGER;
@@ -1218,6 +1275,31 @@
     return status;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+static int nv_acpi_ddc_method_enumerated(struct acpi_device *dev, void *data)
+{
+    acpi_handle *lcd_dev_handle = data;
+    acpi_status status;
+    nv_acpi_integer_t device_id = 0;
+    if (!dev)
+        return 0;
+    status = acpi_evaluate_integer(dev->handle, "_ADR", NULL, &device_id);
+    if (ACPI_FAILURE(status))
+        /* Couldnt query device_id for this device */
+        return 0;
+
+    device_id = (device_id & 0xffff);
+
+    if ((device_id == 0x0110) || (device_id == 0x0118) || (device_id == 0x0400)) /* Only for an LCD*/
+    {
+        *lcd_dev_handle = dev->handle;
+        nv_printf(NV_DBG_INFO, "NVRM: %s Found LCD: %x\n", __FUNCTION__, device_id);
+        return 1;
+    }
+    return 0;
+}
+#endif
+
 /*
  * This function executes a _DDC ACPI method.
  */
@@ -1233,8 +1315,10 @@
     union acpi_object *ddc;
     union acpi_object ddc_arg0 = { ACPI_TYPE_INTEGER };
     struct acpi_object_list input = { 1, &ddc_arg0 };
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
     struct list_head *node, *next;
     nv_acpi_integer_t device_id = 0;
+#endif
     NvU32 i;
     acpi_handle dev_handle  = NULL;
     acpi_handle lcd_dev_handle  = NULL;
@@ -1264,6 +1348,7 @@
         return NV_ERR_NOT_SUPPORTED;
     }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
     list_for_each_safe(node, next, &device->children) 
     {
         struct acpi_device *dev =
@@ -1287,6 +1372,9 @@
         }
 
     }
+#else
+    acpi_dev_for_each_child(device, nv_acpi_ddc_method_enumerated, &lcd_dev_handle);
+#endif
 
     if (lcd_dev_handle == NULL)
     {
--- a/nvidia-drm/nvidia-drm-helper.c
+++ b/nvidia-drm/nvidia-drm-helper.c
@@ -41,6 +41,11 @@
 #include <drm/drm_atomic_uapi.h>
 #endif

+// Add header which is no longer indirectly referenced as of Linux 6.0-rc1
+#if defined(NV_DRM_DRM_FRAMEBUFFER_H_PRESENT)
+#include <drm/drm_framebuffer.h>
+#endif
+
 static void __nv_drm_framebuffer_put(struct drm_framebuffer *fb)
 {
 #if defined(NV_DRM_FRAMEBUFFER_GET_PRESENT)
--- a/nvidia/nv-frontend.c	2019-12-12 06:04:24.000000000 +0800
+++ b/nvidia/nv-frontend.c	2022-05-29 20:00:00.000000000 +0800
@@ -15,7 +15,7 @@
 #include "nv-frontend.h"
 
 #if defined(MODULE_LICENSE)
-MODULE_LICENSE("NVIDIA");
+MODULE_LICENSE("GPL");
 #endif
 #if defined(MODULE_INFO)
 MODULE_INFO(supported, "external");
